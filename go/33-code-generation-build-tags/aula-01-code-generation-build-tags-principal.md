# Módulo 33: Code Generation e Build Tags em Go
## Aula 1: go generate e Build Tags - Automação e Compilação Condicional

Olá! Bem-vindo a este módulo essencial sobre **automação de código** e **compilação condicional** em Go. Até agora você aprendeu a escrever código Go manualmente, mas em projetos profissionais, muitas vezes precisamos **gerar código automaticamente** ou **compilar diferentes versões** do mesmo código dependendo da plataforma, arquitetura ou configurações.

Nesta aula, vamos mergulhar em duas ferramentas poderosas do Go:
1. **`go generate`**: Para automação de geração de código
2. **Build Tags**: Para compilação condicional baseada em condições

Essas ferramentas são fundamentais para manter código limpo, evitar repetição e criar builds otimizados para diferentes ambientes.

---

## 1. go generate - Automação de Geração de Código

### O Que É go generate?

O **`go generate`** é um comando do Go que executa comandos especificados em diretivas especiais `//go:generate` nos arquivos do seu código. Ele permite automatizar tarefas de geração de código, como:

- Gerar métodos String() automaticamente
- Compilar protobufs para Go
- Gerar código a partir de templates
- Embedding de recursos (arquivos, templates)
- Gerar mocks para testes
- E muito mais!

### Por Que Usar go generate?

**Problemas que resolve:**
- ✅ **Repetição de código**: Evita escrever código repetitivo manualmente
- ✅ **Manutenção**: Código gerado é atualizado automaticamente quando necessário
- ✅ **Consistência**: Garante que código gerado segue sempre o mesmo padrão
- ✅ **Produtividade**: Economiza tempo em tarefas repetitivas
- ✅ **Automação**: Integra facilmente em pipelines de build

**Quando usar:**
- Quando você precisa gerar código baseado em definições (ex: protobuf, OpenAPI)
- Quando há código repetitivo que pode ser automatizado
- Quando precisa embed recursos em binários
- Quando precisa gerar mocks ou stubs para testes

### Como Funciona?

O `go generate` procura por diretivas `//go:generate` nos arquivos `.go` e executa os comandos especificados. A sintaxe é:

```go
//go:generate comando argumentos
```

**Importante**: A diretiva deve estar em uma linha que começa com `//go:generate` (sem espaço antes de `go`).

### Sintaxe Básica

```bash
# Executar go generate no pacote atual
go generate ./...

# Executar go generate em um pacote específico
go generate ./pkg/models

# Executar go generate recursivamente
go generate ./...

# Executar com variáveis de ambiente
GOOS=linux go generate ./...
```

### Exemplo 1: Gerando Método String() Automaticamente

Vamos criar um exemplo simples usando a ferramenta `stringer` para gerar métodos `String()` automaticamente:

```go
//go:generate stringer -type=Status

package main

import "fmt"

// Status representa o status de uma tarefa
type Status int

const (
    StatusPending Status = iota
    StatusInProgress
    StatusCompleted
    StatusCancelled
)

func main() {
    status := StatusInProgress
    fmt.Println(status.String()) // "StatusInProgress"
}
```

**Como usar:**

```bash
# 1. Instalar stringer
go install golang.org/x/tools/cmd/stringer@latest

# 2. Executar go generate
go generate ./...

# 3. Isso gerará um arquivo status_string.go com o método String()
```

**Arquivo gerado (status_string.go):**
```go
// Code generated by "stringer -type=Status"; DO NOT EDIT.

package main

import "strconv"

func _() {
    // An "invalid array index" compiler error signifies that the constants have changed.
    // Re-run the stringer command to generate them again.
    var x [1]struct{}
    _ = x[StatusPending-0]
    _ = x[StatusInProgress-1]
    _ = x[StatusCompleted-2]
    _ = x[StatusCancelled-3]
}

const _Status_name = "StatusPendingStatusInProgressStatusCompletedStatusCancelled"

var _Status_index = [...]uint8{0, 13, 28, 43, 57}

func (i Status) String() string {
    if i < 0 || i >= Status(len(_Status_index)-1) {
        return "Status(" + strconv.FormatInt(int64(i), 10) + ")"
    }
    return _Status_name[_Status_index[i]:_Status_index[i+1]]
}
```

### Exemplo 2: Compilando Protobuf

Um dos usos mais comuns do `go generate` é compilar arquivos `.proto` para Go:

```go
//go:generate protoc --go_out=. --go_opt=paths=source_relative user.proto

package main

// O código gerado do protobuf será usado aqui
```

**Como usar:**

```bash
# 1. Instalar protoc-gen-go
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest

# 2. Executar go generate
go generate ./...

# 3. Isso gerará user.pb.go a partir de user.proto
```

### Exemplo 3: Embedding de Recursos

Você pode usar `go generate` para embed arquivos em binários:

```go
//go:generate go run github.com/kevinburke/go-bindata/go-bindata -pkg=assets -o=assets/bindata.go templates/...

package main

import "meuapp/assets"

func main() {
    // Usar templates embedados
    template := assets.MustAsset("templates/index.html")
    // ...
}
```

### Exemplo 4: Gerando Mocks para Testes

Gerar mocks automaticamente para interfaces:

```go
//go:generate mockgen -source=repository.go -destination=mocks/repository_mock.go -package=mocks

package main

// Interface que será mockada
type UserRepository interface {
    FindByID(id int) (*User, error)
    Save(user *User) error
}
```

**Como usar:**

```bash
# 1. Instalar mockgen
go install github.com/golang/mock/mockgen@latest

# 2. Executar go generate
go generate ./...

# 3. Isso gerará mocks/repository_mock.go
```

### Exemplo 5: Múltiplas Diretivas

Você pode ter múltiplas diretivas `//go:generate` no mesmo arquivo:

```go
//go:generate stringer -type=Status
//go:generate go run scripts/generate-validators.go
//go:generate protoc --go_out=. user.proto

package main
```

### Variáveis de Ambiente em go generate

Você pode usar variáveis de ambiente nas diretivas:

```go
//go:generate sh -c "echo 'Build time: $(date)' > build_info.go"

package main
```

Ou usar variáveis do Go:

```go
//go:generate go run generate.go -output=$GOFILE

package main
```

### Boas Práticas com go generate

#### 1. Documentar o Uso

Sempre documente o que cada diretiva faz:

```go
//go:generate stringer -type=Status
// Este comando gera o método String() para o tipo Status
// Execute: go generate ./...
```

#### 2. Versionar Arquivos Gerados

**❌ Erro Comum**: Não versionar arquivos gerados

```bash
# Não fazer isso
echo "*.pb.go" >> .gitignore
```

**✅ Boa Prática**: Versionar arquivos gerados (com exceções)

```bash
# Versionar arquivos gerados
git add *.pb.go

# Mas ignorar temporários
echo "*.tmp.go" >> .gitignore
```

**Por quê?** Arquivos gerados devem ser versionados para:
- Garantir builds reproduzíveis
- Evitar dependências de ferramentas em CI/CD
- Facilitar code review

#### 3. Executar no CI/CD

Sempre execute `go generate` no pipeline:

```yaml
# .github/workflows/ci.yml
- name: Generate code
  run: go generate ./...

- name: Check for changes
  run: |
    git diff --exit-code || (echo "Generated files are out of date" && exit 1)
```

#### 4. Usar Makefile

Facilite a execução com Makefile:

```makefile
.PHONY: generate test build

generate:
	go generate ./...

test:
	go test ./...

build: generate
	go build ./...
```

---

## 2. Build Tags - Compilação Condicional

### O Que São Build Tags?

**Build Tags** (também conhecidos como build constraints) são diretivas especiais que controlam quais arquivos são incluídos na compilação baseado em condições como:

- Sistema operacional (Linux, Windows, macOS, etc.)
- Arquitetura (amd64, arm64, 386, etc.)
- Tags customizadas (dev, prod, test, etc.)

### Por Que Usar Build Tags?

**Problemas que resolve:**
- ✅ **Código específico de plataforma**: Implementações diferentes para cada OS
- ✅ **Feature flags**: Habilitar/desabilitar features por ambiente
- ✅ **Otimização**: Incluir código apenas quando necessário
- ✅ **Testes condicionais**: Testes que só rodam em certas condições
- ✅ **Zero overhead**: Código não usado não é compilado

**Quando usar:**
- Quando você precisa de código específico para cada plataforma
- Quando quer feature flags em tempo de compilação
- Quando precisa otimizar builds para diferentes ambientes
- Quando quer evitar código desnecessário no binário final

### Sintaxe de Build Tags

A sintaxe moderna (Go 1.17+) usa `//go:build`:

```go
//go:build condição
```

A sintaxe antiga (ainda suportada) usa `// +build`:

```go
// +build condição
```

**Recomendação**: Use sempre `//go:build` (sintaxe moderna).

### Condições Comuns

#### Sistema Operacional

```go
//go:build linux
// Código apenas para Linux

//go:build windows
// Código apenas para Windows

//go:build darwin
// Código apenas para macOS

//go:build !windows
// Código para todos OS exceto Windows
```

#### Arquitetura

```go
//go:build amd64
// Código apenas para arquitetura amd64

//go:build arm64
// Código apenas para arquitetura ARM64

//go:build 386
// Código apenas para arquitetura 32-bit x86

//go:build !386
// Código para todas arquiteturas exceto 32-bit
```

#### Combinações

```go
//go:build linux && amd64
// Código apenas para Linux em arquitetura amd64

//go:build linux || darwin
// Código para Linux OU macOS

//go:build windows && !386
// Código para Windows, mas não para 32-bit
```

#### Tags Customizadas

```go
//go:build dev
// Código apenas quando tag "dev" está presente

//go:build prod
// Código apenas quando tag "prod" está presente

//go:build test
// Código apenas quando tag "test" está presente
```

**Como usar tags customizadas:**

```bash
# Compilar com tag "dev"
go build -tags=dev ./...

# Compilar com múltiplas tags
go build -tags=dev,debug ./...

# Testar com tag "test"
go test -tags=test ./...
```

### Exemplo 1: Código Específico de Plataforma

Vamos criar uma função que retorna o caminho de configuração dependendo do OS:

**config_unix.go:**
```go
//go:build linux || darwin || freebsd || openbsd || netbsd

package main

func getConfigPath() string {
    return "/etc/myapp/config.json"
}
```

**config_windows.go:**
```go
//go:build windows

package main

func getConfigPath() string {
    return "C:\\ProgramData\\myapp\\config.json"
}
```

**config_default.go:**
```go
//go:build !linux && !darwin && !freebsd && !openbsd && !netbsd && !windows

package main

func getConfigPath() string {
    return "./config.json"
}
```

**main.go:**
```go
package main

import "fmt"

func main() {
    path := getConfigPath()
    fmt.Println("Config path:", path)
}
```

**Como compilar:**

```bash
# No Linux
go build -o myapp ./...

# No Windows
go build -o myapp.exe ./...

# O Go automaticamente escolhe o arquivo correto baseado no OS
```

### Exemplo 2: Feature Flags

Usar build tags para habilitar/desabilitar features:

**features_dev.go:**
```go
//go:build dev

package main

const (
    EnableDebugLogging = true
    EnableProfiling    = true
    LogLevel           = "debug"
)
```

**features_prod.go:**
```go
//go:build !dev

package main

const (
    EnableDebugLogging = false
    EnableProfiling    = false
    LogLevel           = "info"
)
```

**main.go:**
```go
package main

import "log"

func main() {
    if EnableDebugLogging {
        log.Println("Debug logging enabled")
    }
    
    log.Printf("Log level: %s", LogLevel)
}
```

**Como compilar:**

```bash
# Versão de desenvolvimento (com debug)
go build -tags=dev -o myapp-dev ./...

# Versão de produção (sem debug)
go build -o myapp-prod ./...
```

### Exemplo 3: Implementações Alternativas

Usar build tags para diferentes implementações:

**database_sqlite.go:**
```go
//go:build sqlite

package database

import _ "github.com/mattn/go-sqlite3"

func NewDB() DB {
    return &SQLiteDB{}
}
```

**database_postgres.go:**
```go
//go:build postgres

package database

import _ "github.com/lib/pq"

func NewDB() DB {
    return &PostgresDB{}
}
```

**Como compilar:**

```bash
# Compilar com SQLite
go build -tags=sqlite -o myapp-sqlite ./...

# Compilar com PostgreSQL
go build -tags=postgres -go myapp-postgres ./...
```

### Exemplo 4: Testes Condicionais

Testes que só rodam em certas condições:

**integration_test.go:**
```go
//go:build integration

package main

import "testing"

func TestIntegration(t *testing.T) {
    // Testes de integração que precisam de banco de dados
    // Só rodam quando tag "integration" está presente
}
```

**Como executar:**

```bash
# Rodar testes normais (sem integration)
go test ./...

# Rodar testes de integração
go test -tags=integration ./...
```

### Exemplo 5: Build Tags com go generate

Combinar build tags com go generate:

**generate_dev.go:**
```go
//go:build dev
//go:generate go run scripts/generate-mocks.go -output=mocks

package main
```

**generate_prod.go:**
```go
//go:build !dev
//go:generate go run scripts/generate-stubs.go -output=stubs

package main
```

### Regras Importantes sobre Build Tags

#### 1. Primeira Linha do Arquivo

Build tags devem estar na **primeira linha** do arquivo (após o package, se houver):

```go
//go:build linux
package main  // ✅ Correto
```

```go
package main
//go:build linux  // ❌ ERRADO! Deve estar antes do package
```

#### 2. Linha em Branco Após Build Tag

Deve haver uma linha em branco após a build tag:

```go
//go:build linux

package main  // ✅ Correto (linha em branco)
```

```go
//go:build linux
package main  // ❌ ERRADO! Falta linha em branco
```

#### 3. Múltiplas Condições

Você pode ter múltiplas condições na mesma linha:

```go
//go:build linux && amd64
```

Mas **não** pode ter múltiplas diretivas `//go:build`:

```go
//go:build linux
//go:build amd64  // ❌ ERRADO! Use && na mesma linha
```

#### 4. Arquivos Sem Build Tags

Arquivos sem build tags são **sempre incluídos** na compilação (a menos que tenham build tags que os excluam).

### Build Tags vs Runtime Checks

**Build Tags (Compilação):**
- ✅ Zero overhead (código não compilado)
- ✅ Erros em tempo de compilação
- ❌ Precisa recompilar para mudar

```go
//go:build dev
const Debug = true  // Compilado apenas com -tags=dev
```

**Runtime Checks (Execução):**
- ✅ Flexível (muda sem recompilar)
- ❌ Overhead mínimo
- ❌ Erros em tempo de execução

```go
var Debug = os.Getenv("DEBUG") == "true"  // Verificado em runtime
```

**Quando usar cada um:**
- **Build Tags**: Para código que não deve estar no binário final (debug, features experimentais)
- **Runtime Checks**: Para configurações que mudam frequentemente (log level, feature flags dinâmicas)

---

## 3. Exemplos Práticos Completos

### Exemplo 1: Aplicação com Build Tags e go generate

Vamos criar uma aplicação completa que usa ambos:

**Estrutura:**
```
myapp/
├── main.go
├── status.go
├── config_linux.go
├── config_windows.go
├── features_dev.go
├── features_prod.go
└── go.mod
```

**status.go:**
```go
//go:generate stringer -type=Status

package main

type Status int

const (
    StatusPending Status = iota
    StatusInProgress
    StatusCompleted
)
```

**config_linux.go:**
```go
//go:build linux

package main

func getConfigPath() string {
    return "/etc/myapp/config.json"
}
```

**config_windows.go:**
```go
//go:build windows

package main

func getConfigPath() string {
    return "C:\\ProgramData\\myapp\\config.json"
}
```

**features_dev.go:**
```go
//go:build dev

package main

const EnableDebug = true
```

**features_prod.go:**
```go
//go:build !dev

package main

const EnableDebug = false
```

**main.go:**
```go
package main

import "fmt"

func main() {
    status := StatusInProgress
    fmt.Println("Status:", status.String())
    
    path := getConfigPath()
    fmt.Println("Config path:", path)
    
    if EnableDebug {
        fmt.Println("Debug mode enabled")
    }
}
```

**Como usar:**

```bash
# 1. Gerar código
go generate ./...

# 2. Compilar versão de desenvolvimento para Linux
go build -tags=dev -o myapp-dev-linux ./...

# 3. Compilar versão de produção para Windows
GOOS=windows go build -o myapp-prod-windows.exe ./...
```

### Exemplo 2: Biblioteca com Múltiplas Implementações

**database.go:**
```go
package database

type DB interface {
    Query(sql string) ([]Row, error)
    Close() error
}
```

**database_sqlite.go:**
```go
//go:build sqlite

package database

import _ "github.com/mattn/go-sqlite3"

func NewDB(path string) (DB, error) {
    return newSQLiteDB(path)
}
```

**database_postgres.go:**
```go
//go:build postgres

package database

import _ "github.com/lib/pq"

func NewDB(connStr string) (DB, error) {
    return newPostgresDB(connStr)
}
```

**Como usar:**

```bash
# Compilar com SQLite
go build -tags=sqlite ./...

# Compilar com PostgreSQL
go build -tags=postgres ./...
```

---

## 4. Boas Práticas e Armadilhas Comuns

### Boas Práticas

#### 1. Usar Nomes Descritivos

**❌ Ruim:**
```go
//go:build x
```

**✅ Bom:**
```go
//go:build dev
//go:build integration
//go:build sqlite
```

#### 2. Documentar Build Tags

Sempre documente o propósito de cada build tag:

```go
//go:build dev
// Este arquivo contém configurações de desenvolvimento
// Compile com: go build -tags=dev
```

#### 3. Testar Todas as Combinações

Teste seu código com diferentes build tags:

```bash
# Testar todas as combinações
go test -tags=dev ./...
go test -tags=prod ./...
go test -tags=integration ./...
```

#### 4. Versionar Arquivos Gerados

Como mencionado antes, versionar arquivos gerados por `go generate`.

### Armadilhas Comuns

#### 1. Esquecer Linha em Branco

**❌ Erro:**
```go
//go:build linux
package main  // Falta linha em branco!
```

**✅ Correto:**
```go
//go:build linux

package main
```

#### 2. Build Tags em Arquivos de Teste

Build tags em arquivos de teste funcionam, mas podem ser confusos:

```go
//go:build integration

package main

import "testing"

func TestIntegration(t *testing.T) {
    // Este teste só roda com -tags=integration
}
```

#### 3. Múltiplas Implementações Sem Default

**❌ Problema:**
```go
// database_sqlite.go
//go:build sqlite

// database_postgres.go
//go:build postgres

// Se nenhuma tag for especificada, nenhum arquivo será compilado!
```

**✅ Solução:**
```go
// database_sqlite.go
//go:build sqlite || (!postgres && !mysql)

// database_postgres.go
//go:build postgres
```

---

## Resumo dos Conceitos

| Conceito | Descrição |
|----------|-----------|
| **go generate** | Comando que executa diretivas `//go:generate` para automação |
| **//go:generate** | Diretiva que especifica comando a ser executado |
| **Build Tags** | Diretivas `//go:build` que controlam inclusão de arquivos na compilação |
| **//go:build** | Sintaxe moderna para build tags (Go 1.17+) |
| **// +build** | Sintaxe antiga para build tags (ainda suportada) |
| **-tags** | Flag do go build/test para especificar tags customizadas |

---

## Conclusão

Dominar `go generate` e Build Tags é essencial para:

1. **Automação Profissional**: Reduzir trabalho manual e repetitivo
2. **Código Limpo**: Evitar código duplicado e manter consistência
3. **Builds Otimizados**: Criar binários específicos para cada ambiente
4. **Feature Flags**: Controlar features em tempo de compilação
5. **Portabilidade**: Suportar múltiplas plataformas facilmente

Essas ferramentas são fundamentais para projetos Go profissionais e escaláveis. Integre-as no seu workflow e veja sua produtividade aumentar!

Na próxima parte desta aula, vamos simplificar esses conceitos com analogias do dia a dia para fixar melhor o aprendizado!

